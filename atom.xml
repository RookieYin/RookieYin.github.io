<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RookieYin&#39;s Note</title>
  
  
  <link href="http://rookieyin.github.io/atom.xml" rel="self"/>
  
  <link href="http://rookieyin.github.io/"/>
  <updated>2022-10-08T09:05:26.479Z</updated>
  <id>http://rookieyin.github.io/</id>
  
  <author>
    <name>Yin Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adversarial Cross-View Disentangled Graph Contrastive Learning</title>
    <link href="http://rookieyin.github.io/a9b6475c1860/"/>
    <id>http://rookieyin.github.io/a9b6475c1860/</id>
    <published>2022-10-08T11:26:03.000Z</published>
    <updated>2022-10-08T09:05:26.479Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2209.07699&quot;&gt;https://arxiv.org/pdf/2209.07699&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Adversarial Cross-View Disentangled Graph Contrastive Learning，2022，arxiv preprint&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 信息论（IB）角度出发，故事讲得比较完整，说的挺有道理的，disentangled可以自圆其说。至于adversarial，感觉是拿来凑数的，从消融实验也可以看出，添加对抗训练后，并没有给模型性能带来太大提升。&lt;/p&gt;
&lt;p&gt;作者的disentanglement我觉得还挺有意思的，从数据增强出发，引出两个视角之间的InfoMax会引入标签无关的冗余信息。作者通过对图编码器学习到的图嵌入&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.44444em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord mathbf&quot;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;进行disentangle，得到augmentation-induced factors对应的表示&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;z&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf z^{aug}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.664392em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathbf&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.664392em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;mord mathdefault mtight&quot; style=&quot;margin-right:0.03588em;&quot;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;和图essential factors对应的表示&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi mathvariant=&quot;bold&quot;&gt;z&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\mathbf z^{inv}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.824664em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;&lt;span class=&quot;mord mathbf&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;msupsub&quot;&gt;&lt;span class=&quot;vlist-t&quot;&gt;&lt;span class=&quot;vlist-r&quot;&gt;&lt;span class=&quot;vlist&quot; style=&quot;height:0.824664em;&quot;&gt;&lt;span style=&quot;top:-3.063em;margin-right:0.05em;&quot;&gt;&lt;span class=&quot;pstrut&quot; style=&quot;height:2.7em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;sizing reset-size6 size3 mtight&quot;&gt;&lt;span class=&quot;mord mtight&quot;&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;mord mathdefault mtight&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;mord mathdefault mtight&quot; style=&quot;margin-right:0.03588em;&quot;&gt;v&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，然后对比两个视角的inv嵌入来优化模型。感觉这个点创新性比较足，而且非常符合我们的直觉。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Disentangled Contrastive Learning on Graphs</title>
    <link href="http://rookieyin.github.io/d38a70d07b07/"/>
    <id>http://rookieyin.github.io/d38a70d07b07/</id>
    <published>2022-10-07T11:26:03.000Z</published>
    <updated>2022-10-08T09:06:19.600Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://proceedings.neurips.cc/paper/2021/file/b6cda17abb967ed28ec9610137aa45f7-Paper.pdf&quot;&gt;https://proceedings.neurips.cc/paper/2021/file/b6cda17abb967ed28ec9610137aa45f7-Paper.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Disentangled Contrastive Learning on Graphs，2021，NIPS&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 把disentangled gnn引入图对比学习中，作者设计了一种distangled图编码器，为每个图生成K个factorized representation。编码器的具体实现上非常简单，就是使用K个参数不同的GNN，生成K个表示。所谓disentangle，就是现实世界中的图往往都是在多种因素驱动下形成的，比如社交图中，可能是在朋友、同事、兴趣爱好等多种因素的驱动下形成的。因此我们只用一个representation来描述这个图是不够精确的，我们应该对这些因素进行解耦，为每个因素都学习一个独立的representation。&lt;/p&gt;
&lt;p&gt;由于每个样本有K个表示，所以作者还需要重新设计模型优化模式，通过ELBO来优化模型。文章方法比较简单，感觉是把有监督中的一些disentangled方法和优化方式引入对比学习中，不过从实验结果来看，作者提出的模型性能确实很好。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Enhancing Graph Contrastive Learning with Node Similarity</title>
    <link href="http://rookieyin.github.io/4f35b4df523d/"/>
    <id>http://rookieyin.github.io/4f35b4df523d/</id>
    <published>2022-10-06T11:26:03.000Z</published>
    <updated>2022-10-06T14:06:57.443Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2208.06743&quot;&gt;https://arxiv.org/pdf/2208.06743&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enhancing Graph Contrastive Learning with Node Similarity，2022，arxiv preprint&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;一篇针对负样本采样的文章。作者认为现有的很多GCL方法是次优的，原因有二：（1）直接将所有不同节点看作负样本不好，因为这些节点里面包含false-negative samples，即那些和query节点具有相同语义（相同标签）的节点；（2）正样本通常只有1个，这不足以让模型拥有push positive sample together的能力。作者设计了一种方案，基于节点间相似度来选取正负样本，并对GCL的对比损失进行改进，提出了一种enhanced objective。文章方法简单，思想和Protopical Graph Contrastive Learning那篇比较像，不过多了一个正样本的选取。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫环问题</title>
    <link href="http://rookieyin.github.io/45dfa1e593ed/"/>
    <id>http://rookieyin.github.io/45dfa1e593ed/</id>
    <published>2022-10-06T05:39:48.000Z</published>
    <updated>2022-10-06T14:09:01.302Z</updated>
    
    
    <summary type="html">&lt;p&gt;约瑟夫环是一个经典的算法题，总是忘记其解法，今天写篇博客记录下，方便复习同时加深印象！&lt;/p&gt;
&lt;h2 id=&quot;leetcode-剑指offer-62&quot;&gt;LeetCode 剑指Offer 62&lt;/h2&gt;
&lt;p&gt;这里以&lt;a href=&quot;https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/&quot;&gt;LeetCode 剑指 Offer 62题&lt;/a&gt;为例，讲解下约瑟夫环问题的解决思路（[Leetcode主站 1823](&lt;a href=&quot;https://leetcode.cn/problems/find-the-winner-of-the-circular-game/&quot;&gt;1823. 找出游戏的获胜者&lt;/a&gt;)也是同样的问题）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目描述如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。”&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Leetcode" scheme="http://rookieyin.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>GRAPH CONTRASTIVE LEARNING WITH PERSONALIZED AUGMENTATION</title>
    <link href="http://rookieyin.github.io/f80da412db0f/"/>
    <id>http://rookieyin.github.io/f80da412db0f/</id>
    <published>2022-10-05T11:26:03.000Z</published>
    <updated>2022-10-06T05:20:38.383Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2209.06560&quot;&gt;https://arxiv.org/pdf/2209.06560&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GRAPH CONTRASTIVE LEARNING WITH PERSONALIZED AUGMENTATION，2022，arxiv preprint&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 本文提出了一种自适应增强图对比学习方法PGA。和现有自动GCL方法相比，它包含一个增强策略选择器，允许为每个图根据其自身特性选择最优的增强策略组合（印象中其他自动GCL也能实现这个效果）。从实验结果看，PGA性能还是不错的，不过个人认为本文提出的增强策略选择器的可解释较差，作者没有给出相关理论证明，甚至没有太多的关于为什么这样设计的文字解释，借鉴意义不大。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Augmentation-Free Graph Contrastive Learning with Performance Guarantee</title>
    <link href="http://rookieyin.github.io/cbcb4550bd3d/"/>
    <id>http://rookieyin.github.io/cbcb4550bd3d/</id>
    <published>2022-10-05T11:26:03.000Z</published>
    <updated>2022-10-06T04:50:30.516Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2204.04874&quot;&gt;https://arxiv.org/pdf/2204.04874&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Augmentation-Free Graph Contrastive Learning with Performance Guarantee，2022，arxiv preprint&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;本文提出了一种新的无需增强的图对比学习模型AF-GCL。数据增强的目的是让我们能够选取正负样本对，以此为自监督信号学习节点表示，那么无须增强的AF-GCL是怎样选取正负样本对的呢？AF-GCL的方案很简单，根据节点嵌入选择正负样本对。具体来说，对于query节点，从它T-hop邻居节点集合中，选择相似度最高的K个节点作为正样本，其余节点作为负样本。作者从理论上分析并证明了AF-GCL可以同时适用于同构和异构图，并且能有很不错的表现，而现有的GCL方法在异构图上通常表现较差。&lt;/p&gt;
&lt;p&gt;总的来说，这篇文章还是挺好的，虽然提出的模型比较简单粗暴，但是实验效果还不错，并且文章中给了很多理论分析和证明。看了眼，最近两年，关于GNN的频域研究似乎挺火的，看到了好几篇相关的顶会文章，作者应该是基于现有的一些研究，迁移到对比学习中来了。这篇文章目前还没投出去，盲猜作者投了一手ICML2022。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Adversarial Graph Contrastive Learning with Information Regularization</title>
    <link href="http://rookieyin.github.io/59408777a096/"/>
    <id>http://rookieyin.github.io/59408777a096/</id>
    <published>2022-10-04T11:26:03.000Z</published>
    <updated>2022-10-04T08:20:09.064Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://dl.acm.org/doi/pdf/10.1145/3485447.3512183&quot;&gt;https://dl.acm.org/doi/pdf/10.1145/3485447.3512183&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Adversarial Graph Contrastive Learning with Information Regularization，2022，WWW&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 个人觉得这篇文章创新性是比较强的，第一次看到这种将对抗训练引入对比学习中的文章，对抗训练和对比学习结合的方式也比较新颖。关于信息正则化项的理论分析，思路也很清晰，容易看懂，值得借鉴。&lt;/p&gt;
&lt;p&gt;实验部分内容不多，但是相对比较完整，ARIEL性能也还不错。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Simple unsupervised graph representation learning</title>
    <link href="http://rookieyin.github.io/e803960de55b/"/>
    <id>http://rookieyin.github.io/e803960de55b/</id>
    <published>2022-10-04T11:26:03.000Z</published>
    <updated>2022-10-04T08:48:55.948Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ojs.aaai.org/index.php/AAAI/article/view/20748/20507&quot;&gt;https://ojs.aaai.org/index.php/AAAI/article/view/20748/20507&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/YujieMo/SUGRL&quot;&gt;https://github.com/YujieMo/SUGRL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Simple unsupervised graph representation learning，2022，AAAI&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 现有的GCL方法通常时间复杂度比较高，导致难以应用到大规模数据集，主要有一下3点原因：（1）数据增强；（2）高维嵌入；（3）损失函数。本文作者提出了一种简单高效的图对比学习方法SUGRL，作者删掉了GCL中的数据增强和损失函数，并且重新设计了一个boundary loss。和现有GCL方法相比，SUGRL训练速度确实非常快，并且在节点分类任务上也具有不错的性能。总的来说，这篇文章还是不错的，值得借鉴，如果有更多关于SUGRL的理论分析和证明就更好了。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CCGL: Contrastive Cascade Graph Learning</title>
    <link href="http://rookieyin.github.io/fbae03233e49/"/>
    <id>http://rookieyin.github.io/fbae03233e49/</id>
    <published>2022-10-03T11:26:03.000Z</published>
    <updated>2022-10-04T08:47:33.942Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2107.12576&quot;&gt;https://arxiv.org/pdf/2107.12576&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Xovee/ccgl&quot;&gt;https://github.com/Xovee/ccgl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CCGL: Contrastive Cascade Graph Learning，2022，TKDE&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;算是一篇领域迁移的文章吧，提出了CCGL模型，将对比学习引入级联图学习中，同时结合了预训练-微调模式和知识蒸馏。文章值得参考的一点应该是在级联图中如何进行数据增强，CCGL其他的模块感觉参考意义不大，有点A+B的感觉。必须要吐槽的一点是，文章Introduction和动机写的太烂了！！读这部分的时候，明显感觉到，先东拼西凑设计好模型，再编故事。虽然我们可能经常这样，但是作者故事编的有点太烂了，强行根据CCGL的功能来编这篇工作希望解决的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Augmentation-Free Self-Supervised Learning on Graphs</title>
    <link href="http://rookieyin.github.io/8ab5ae2852a0/"/>
    <id>http://rookieyin.github.io/8ab5ae2852a0/</id>
    <published>2022-10-03T11:26:03.000Z</published>
    <updated>2022-10-04T08:43:32.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ojs.aaai.org/index.php/AAAI/article/view/20700/20459&quot;&gt;https://ojs.aaai.org/index.php/AAAI/article/view/20700/20459&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Namkyeong/AFGRL&quot;&gt;https://github.com/Namkyeong/AFGRL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Augmentation-Free Self-Supervised Learning on Graphs ，2022，AAAI&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;挺好的一篇文章，故事讲得很完整，方法也挺新颖的。作者提出了一种无须增强的GCL方法，利用基于节点表示的kNN获取正样本集合的。在此基础上，考虑到节点的局部机构信息和全局语义信息，使用基于结构的kNN算法和聚类算法，对第一步获取到的正样本集合进行过滤，达到降噪的目的。总的来说，方法比较新，思路很清晰，故事也很完整。至于实验结果，基础对比实验效果一般，不过消融实验、可视化和参数敏感性实验都挺好的，内容比较完整。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SAIL: Self-Augmented Graph Contrastive Learning</title>
    <link href="http://rookieyin.github.io/cb2b42e6046d/"/>
    <id>http://rookieyin.github.io/cb2b42e6046d/</id>
    <published>2022-10-02T11:26:03.000Z</published>
    <updated>2022-10-04T08:17:35.410Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2009.00934&quot;&gt;https://arxiv.org/pdf/2009.00934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SAIL: Self-Augmented Graph Contrastive Learning，2022，AAAI&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;作者提出了一种自增强GCL方法SAIL，和普通GCL方法相比，SAIL没有使用任何增强技术，而是将节点原始输入特征和GNNs学习到的节点表示看作两个视角进行对比。再此基础上，作者认为模型还存在问题，这里正负样本对的选取是通过edge connectivity来进行的，可能无法代表整个节点表示分布的全貌，并且可能导致模型偏向于链路预测任务（在其他pretext task，比如节点分类中表现一般）。为了解决这个问题，作者提出了一种self-distilling方法，包含intra-和inter-distilling两个模块。intra-distilling可以保证学习到的节点表示和原始输入特征具有相同的分布。inter-distilliing可以让浅层GNNs模拟出深层GNNs的效果，并且不存在过平滑问题。&lt;/p&gt;
&lt;p&gt;整体来说，文章还可以，实验比较丰富，实验结果也挺可观的。不过个人感觉，SAIL中的对比策略和知识蒸馏组合在一起有点A+B的意思，结构不是那么连贯，故事不够完整。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Prototypical Graph Contrastive Learning</title>
    <link href="http://rookieyin.github.io/33e72210426f/"/>
    <id>http://rookieyin.github.io/33e72210426f/</id>
    <published>2022-10-01T11:26:03.000Z</published>
    <updated>2022-10-02T05:11:20.112Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2106.09645&quot;&gt;https://arxiv.org/pdf/2106.09645&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ha-lins/pgcl&quot;&gt;https://github.com/ha-lins/pgcl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Prototypical Graph Contrastive Learning，2022，TNNLS&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 文章要解决的一个核心问题就是：GCL负样本采样阶段存在的“sampling bias”问题，即可能选取到的“false negative sample”（即和目标query具有相同语义的负样本）。现有的GCL方法，对于负样本的选取基本都是均匀采样，不考虑负样本和锚点之间的相似度。作者在PGCL中首先对样本进行聚类，计算每个类别的原型向量，然后将和锚点处于不同簇的其他样本视作正负样本，处于相同簇的样本视为假负样本。另外，作者根据样本所在簇的原型和锚点所在簇原型之间距离计算权重用于对比损失的定义。感觉目前学术界对于GCL的研究，基本都是将CV和NLP中对比学习方法拓展到图邻域，可以多多关注CV中对比学习的最新进展。2021ICLR中有一篇名为“ PROTOTYPICAL CONTRASTIVE LEARNING OF UNSUPERVISED REPRESENTATIONS”的CV论文，我没有看着篇文章，不知道和本文是否有联系。2021ICLR还有一篇“ CONTRASTIVE LEARNING WITH HARD NEGATIVE SAMPLES ”的论文，和本文负样本采样思想差不多。因此，总的来看作者可能还是将CV中的方法迁移到图学习中。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="http://rookieyin.github.io/40756c5f7820/"/>
    <id>http://rookieyin.github.io/40756c5f7820/</id>
    <published>2022-09-12T05:39:48.000Z</published>
    <updated>2022-10-04T14:07:46.292Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;一些定义&quot;&gt;一些定义&lt;/h2&gt;
&lt;p&gt;给定N个带有权值的叶子节点，构造一棵二叉树，如果该树的&lt;strong&gt;带权路径长度最小&lt;/strong&gt;，那么它是一棵最优二叉树，即&lt;strong&gt;哈夫曼树&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈夫曼树" scheme="http://rookieyin.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>行为型——责任链模式</title>
    <link href="http://rookieyin.github.io/1b76d52cc09c/"/>
    <id>http://rookieyin.github.io/1b76d52cc09c/</id>
    <published>2022-08-23T07:08:10.000Z</published>
    <updated>2022-10-04T14:03:20.996Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;</summary>
        
      
    
    
    
    <category term="设计模式" scheme="http://rookieyin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://rookieyin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优</title>
    <link href="http://rookieyin.github.io/77a9c8309105/"/>
    <id>http://rookieyin.github.io/77a9c8309105/</id>
    <published>2022-08-17T14:34:49.000Z</published>
    <updated>2022-10-04T13:48:16.107Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;何时进行jvm调优&quot;&gt;何时进行JVM调优&lt;/h2&gt;
&lt;p&gt;遇到以下情况，就需要考虑进行JVM调优了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heap内存（老年代）持续上涨达到设置的最大内存值；&lt;/li&gt;
&lt;li&gt;Full GC 次数频繁；&lt;/li&gt;
&lt;li&gt;GC 停顿时间过长（超过1秒）；&lt;/li&gt;
&lt;li&gt;应用出现OutOfMemory 等内存异常；&lt;/li&gt;
&lt;li&gt;应用中有使用本地缓存且占用大量内存空间；&lt;/li&gt;
&lt;li&gt;系统吞吐量与响应性能不高或下降。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="JVM" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/JVM/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="优化" scheme="http://rookieyin.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>联合索引怎么用</title>
    <link href="http://rookieyin.github.io/426b292b8fce/"/>
    <id>http://rookieyin.github.io/426b292b8fce/</id>
    <published>2022-08-11T06:28:18.000Z</published>
    <updated>2022-10-04T13:50:35.877Z</updated>
    
    
    <summary type="html">&lt;p&gt;InnoDB中，除了聚簇索引和单个列的辅助索引外，我们还可以将多个列建立联合索引：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ADD&lt;/span&gt; INDEX abc(a, b, c)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过上面一行SQL，我们就可以建立a、b、c之间的联合索引。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="MySQL" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/MySQL/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="http://rookieyin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://rookieyin.github.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://rookieyin.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Java静态绑定与动态绑定</title>
    <link href="http://rookieyin.github.io/6a5e2bd46dc2/"/>
    <id>http://rookieyin.github.io/6a5e2bd46dc2/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:31:05.018Z</updated>
    
    
    <summary type="html">&lt;p&gt;文章转自&lt;a href=&quot;https://www.jianshu.com/p/4277bbcab647&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、当子类和父类存在同一个方法，子类重写了父类的方法，程序在运行时调用方法是调用父类的方法还是子类的重写方法呢？&lt;br&gt;
2、当一个类中存在方法名相同但参数不同(重载)的方法，程序在执行的时候该如何辨别区分使用哪个方法呢？&lt;br&gt;
在Java中我们使用静态绑定（static binding）和动态绑定（Dynamic binding）来解决，那么什么是绑定？什么是静态绑定？什么又是动态绑定？有什么区别？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java， 多态" scheme="http://rookieyin.github.io/tags/Java%EF%BC%8C-%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>static代码块、构造函数等执行顺序</title>
    <link href="http://rookieyin.github.io/4ad132728a73/"/>
    <id>http://rookieyin.github.io/4ad132728a73/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:31:24.922Z</updated>
    
    
    <summary type="html">&lt;p&gt;文章转自&lt;a href=&quot;https://www.jianshu.com/p/0c4223e0702b&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序：&lt;br&gt;
父类静态块–&amp;gt;子类静态块–&amp;gt; main方法–&amp;gt;父类构造代码块 --&amp;gt;父类构造函数–&amp;gt;子类构造代码块–&amp;gt;子类构造函数，同一级别代码块按顺序执行。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类和继承</title>
    <link href="http://rookieyin.github.io/e2218c103027/"/>
    <id>http://rookieyin.github.io/e2218c103027/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:17:20.905Z</updated>
    
    
    <summary type="html">&lt;p&gt;文章转自：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3803432.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java三大特性</title>
    <link href="http://rookieyin.github.io/01a29da4a7e8/"/>
    <id>http://rookieyin.github.io/01a29da4a7e8/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:17:58.961Z</updated>
    
    
    <summary type="html">&lt;p&gt;Java作为面向对象语言，具有封装、继承、多态三大特性，以及重写和重载功能。本文对这几个概念做一个详细介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
