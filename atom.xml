<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RookieYin&#39;s Note</title>
  
  
  <link href="http://rookieyin.github.io/atom.xml" rel="self"/>
  
  <link href="http://rookieyin.github.io/"/>
  <updated>2022-06-11T07:49:24.962Z</updated>
  <id>http://rookieyin.github.io/</id>
  
  <author>
    <name>Yin Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快排的3种实现方式</title>
    <link href="http://rookieyin.github.io/b991887dca39/"/>
    <id>http://rookieyin.github.io/b991887dca39/</id>
    <published>2022-06-11T07:48:05.000Z</published>
    <updated>2022-06-11T07:49:24.962Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文循序渐进的总结一下：单路、双路和三路，三种快排实现方式。大家可以去&lt;a href=&quot;https://leetcode.cn/problems/sort-an-array/&quot;&gt;912. 排序数组&lt;/a&gt;验证自己代码的正确性。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://rookieyin.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL连接查询</title>
    <link href="http://rookieyin.github.io/b20020a2ff1b/"/>
    <id>http://rookieyin.github.io/b20020a2ff1b/</id>
    <published>2022-06-11T06:28:18.000Z</published>
    <updated>2022-06-11T06:31:56.532Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文简单总结一下MySQL中常用的连接查询，以及连接查询的底层原理。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="MySQL" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/MySQL/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="http://rookieyin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://rookieyin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Hyperloglog算法</title>
    <link href="http://rookieyin.github.io/956d20e7408c/"/>
    <id>http://rookieyin.github.io/956d20e7408c/</id>
    <published>2022-06-10T11:50:48.000Z</published>
    <updated>2022-06-10T11:54:52.656Z</updated>
    
    
    <summary type="html">&lt;p&gt;在Redis中有一种叫作Hyperloglog的数据结构，用于基数统计，其背后原理就是Hyperloglog算法，本文介绍下HyperLogLog算法的原理和具体实现方式。主要包括LLC算法原理及实现，HLLC算法原理及实现，Redis中HeperLogLog的具体实现。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="统计" scheme="http://rookieyin.github.io/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Bringing Your Own View: Graph Contrastive Learning without Prefabricated Data Augmentations</title>
    <link href="http://rookieyin.github.io/b1598f2ddb56/"/>
    <id>http://rookieyin.github.io/b1598f2ddb56/</id>
    <published>2022-06-10T11:26:03.000Z</published>
    <updated>2022-06-10T11:46:25.528Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2201.01702&quot;&gt;https://arxiv.org/pdf/2201.01702&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Shen-Lab/GraphCL_Automated&quot;&gt;https://github.com/Shen-Lab/GraphCL_Automated&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Bringing Your Own View: Graph Contrastive Learning without Prefabricated Data Augmentations ，2022，WSDM&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SimGRACE: A Simple Framework for Graph Contrastive Learning without Data Augmentation</title>
    <link href="http://rookieyin.github.io/36ea8234990f/"/>
    <id>http://rookieyin.github.io/36ea8234990f/</id>
    <published>2022-06-10T11:26:03.000Z</published>
    <updated>2022-06-10T11:47:45.295Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2202.03104&quot;&gt;https://arxiv.org/pdf/2202.03104&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/junxia97/simgrace&quot;&gt;https://github.com/junxia97/simgrace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SimGRACE: A Simple Framework for Graph Contrastive Learning without Data Augmentation，2022，WWW&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RoSA: A Robust Self-Aligned Framework for Node-Node Graph Contrastive Learning</title>
    <link href="http://rookieyin.github.io/5ac7bfb92e9a/"/>
    <id>http://rookieyin.github.io/5ac7bfb92e9a/</id>
    <published>2022-06-10T11:26:03.000Z</published>
    <updated>2022-06-10T11:45:45.836Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2204.13846&quot;&gt;https://arxiv.org/pdf/2204.13846&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhuyun97/rosa&quot;&gt;https://github.com/zhuyun97/rosa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RoSA: A Robust Self-Aligned Framework for Node-Node Graph Contrastive Learning，2022，IJCAI&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Augmentations in Graph Contrastive Learning: Current Methodological Flaws &amp; Towards Better Practices</title>
    <link href="http://rookieyin.github.io/9409fcf95bcf/"/>
    <id>http://rookieyin.github.io/9409fcf95bcf/</id>
    <published>2022-06-10T11:26:03.000Z</published>
    <updated>2022-06-10T11:45:36.354Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://dl.acm.org/doi/pdf/10.1145/3485447.3512200&quot;&gt;https://dl.acm.org/doi/pdf/10.1145/3485447.3512200&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Augmentations in Graph Contrastive Learning: Current Methodological Flaws &amp;amp; Towards Better Practices ，2022，WWW&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 第一次看到这种全是实验的文章，个人觉得这篇文章有两个点比较有启发性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;除了accuracy 之外，我们需要关注一些其他指标，比如affinity等，帮助我们更好的评价一个模型。&lt;/li&gt;
&lt;li&gt;context-aware augmentation，之前一直没有关注过这一点，结合领域知识设计一个增强策略。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过这篇文章，也有一些点是有待商榷的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文章中实验的通用性，这篇文章作者只关注了图分类数据集，然后使用的DAGAs策略也比较有限&lt;/li&gt;
&lt;li&gt;作者虽然提到了context-aware augmentation，但是没有提出更具体的设计方案。使用的两个case也比较特殊。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群</title>
    <link href="http://rookieyin.github.io/621962d42a8e/"/>
    <id>http://rookieyin.github.io/621962d42a8e/</id>
    <published>2022-05-16T12:38:14.000Z</published>
    <updated>2022-06-11T13:41:48.395Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文内容基本全部来自：&lt;a href=&quot;https://www.cnblogs.com/kismetv/p/9853040.html&quot;&gt;https://www.cnblogs.com/kismetv/p/9853040.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;集群，即Redis Cluster，是Redis 3.0开始引入的分布式存储方案。&lt;/p&gt;
&lt;p&gt;集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。集群的作用主要有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据分区&lt;/strong&gt;：将数据分散到多个节点，一方面突破Redis单机内存大小限制，另一方面可以做读写负载均衡，大大提高集群响应能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用&lt;/strong&gt;：Redis集群支持主从复制和自动故障转移，当任意节点发生故障时，集群仍能够对外提供服务。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Redis" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="http://rookieyin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="redis" scheme="http://rookieyin.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵</title>
    <link href="http://rookieyin.github.io/feac293ea536/"/>
    <id>http://rookieyin.github.io/feac293ea536/</id>
    <published>2022-05-15T12:38:14.000Z</published>
    <updated>2022-06-11T13:36:16.158Z</updated>
    
    
    <summary type="html">&lt;p&gt;Redis主从复制的作用有数据热备、负载均衡、故障恢复等；但主从复制存在的一个问题是故障恢复无法自动化。本文将要介绍的哨兵，它基于Redis主从复制，主要作用便是&lt;strong&gt;解决主节点故障恢复的自动化问题&lt;/strong&gt;，进一步提高系统的高可用性。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Redis" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Redis/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="http://rookieyin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="redis" scheme="http://rookieyin.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>raft算法是个啥</title>
    <link href="http://rookieyin.github.io/c601abda57b3/"/>
    <id>http://rookieyin.github.io/c601abda57b3/</id>
    <published>2022-05-13T12:38:14.000Z</published>
    <updated>2022-06-01T14:29:19.467Z</updated>
    
    
    <summary type="html">&lt;p&gt;之前学Redis集群相关知识时候遇到过Raft算法，今天系统的学习一下Raft算法的一些细节。&lt;/p&gt;
&lt;p&gt;在继续往下阅读之前可以，先看一个&lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot;&gt;动画&lt;/a&gt;，简单了解下Raft算法。或者通过&lt;a href=&quot;https://raft.github.io/raftscope/index.html&quot;&gt;这个&lt;/a&gt;实操一下！&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://rookieyin.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="分布式" scheme="http://rookieyin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>rand(7)模拟rand(10)的背后</title>
    <link href="http://rookieyin.github.io/f85e1f123fb5/"/>
    <id>http://rookieyin.github.io/f85e1f123fb5/</id>
    <published>2022-05-07T05:39:48.000Z</published>
    <updated>2022-06-01T12:47:15.748Z</updated>
    
    
    <summary type="html">&lt;p&gt;刷LeetCode遇到这样一道题：&lt;a href=&quot;https://leetcode.cn/problems/implement-rand10-using-rand7/&quot;&gt;用 Rand7() 实现 Rand10()&lt;/a&gt;，本文以这题为引子，深入探讨一下其背后的一些知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目描述如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。&lt;/p&gt;
&lt;p&gt;你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="随机化" scheme="http://rookieyin.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>B-树</title>
    <link href="http://rookieyin.github.io/1ffc37519baa/"/>
    <id>http://rookieyin.github.io/1ffc37519baa/</id>
    <published>2022-05-06T05:39:48.000Z</published>
    <updated>2022-06-01T12:39:37.612Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;b-树&quot;&gt;B-树&lt;/h2&gt;
&lt;p&gt;B-树，这里的 B 表示 balance( 平衡的意思),B-树是一种多路自平衡的搜索树（B树是&lt;strong&gt;一颗多路平衡查找树&lt;/strong&gt;）&lt;br&gt;
。它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。下图是 B-树的简化图：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/images/1446087-bc023e47bc74cfa1.webp&quot; style=&quot;width:800px;&quot;&gt;&lt;/img&gt;&lt;/center&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="http://rookieyin.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洗牌算法</title>
    <link href="http://rookieyin.github.io/8d739821694e/"/>
    <id>http://rookieyin.github.io/8d739821694e/</id>
    <published>2022-05-05T05:39:48.000Z</published>
    <updated>2022-06-01T12:39:00.404Z</updated>
    
    
    <summary type="html">&lt;p&gt;所谓“洗牌算法”，就是把一组序列完全打乱，怎样才算乱呢？需要满足这样一个条件：&lt;strong&gt;对于包含n个元素的序列，每个元素出现在每个位置的概率都是&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;/&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;1/n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;base&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:1em;vertical-align:-0.25em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mord&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mord mathdefault&quot;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一种直白的方法就是，统计序列的全排列，然后在全排列集合中随机选取一各排列出来。这种方法虽然简单，但是无论是空间还是时间复杂度都太高了，有没有其他性能更高的算法呢？当然有，本文简单总结下集中常用的洗牌算法。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="随机化" scheme="http://rookieyin.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://rookieyin.github.io/3da51d7b8480/"/>
    <id>http://rookieyin.github.io/3da51d7b8480/</id>
    <published>2022-05-04T05:39:48.000Z</published>
    <updated>2022-06-01T12:38:02.867Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;拓扑排序，我的理解就是：&lt;strong&gt;有向图&lt;/strong&gt;中所有节点的&lt;strong&gt;一种排列&lt;/strong&gt;，这个排列需要满足下面两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列包含图中所有节点，且每个节点只出现一次；&lt;/li&gt;
&lt;li&gt;若A在序列中排在B的前面，则图中不存在从B到A的路径。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://rookieyin.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="图" scheme="http://rookieyin.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树</title>
    <link href="http://rookieyin.github.io/325f8721ea9c/"/>
    <id>http://rookieyin.github.io/325f8721ea9c/</id>
    <published>2022-05-03T05:39:48.000Z</published>
    <updated>2022-06-01T12:37:18.002Z</updated>
    
    
    <summary type="html">&lt;p&gt;平衡二叉树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="http://rookieyin.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="排序" scheme="http://rookieyin.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://rookieyin.github.io/14bdfa95fb86/"/>
    <id>http://rookieyin.github.io/14bdfa95fb86/</id>
    <published>2022-05-03T05:39:48.000Z</published>
    <updated>2022-06-01T12:33:14.785Z</updated>
    
    
    <summary type="html">&lt;p&gt;并查集，是一种高级数据结构，常用于&lt;strong&gt;数据分组&lt;/strong&gt;问题。本文简单介绍一下并查集相关概念以及实现方法，并附带一些leetcode练习题。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集" scheme="http://rookieyin.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>链表排序</title>
    <link href="http://rookieyin.github.io/f106f4426061/"/>
    <id>http://rookieyin.github.io/f106f4426061/</id>
    <published>2022-05-02T05:39:48.000Z</published>
    <updated>2022-06-01T12:25:22.060Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/sort-list/&quot;&gt;148. 排序链表&lt;/a&gt;的最优方法应该是归并排序，鉴于面试时候经常会问链表快排，本文简单总结下链表排序的归并和快排方法。至于插入排序或者冒泡排序什么的，比较简单，本文不作介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://rookieyin.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="链表" scheme="http://rookieyin.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题总结</title>
    <link href="http://rookieyin.github.io/a66897223478/"/>
    <id>http://rookieyin.github.io/a66897223478/</id>
    <published>2022-04-19T05:39:48.000Z</published>
    <updated>2022-06-01T12:31:08.799Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近刷leetcode过程中遇到了很多背包问题，趁此机会总结下如何用动态规划解决背包问题及其各种变体。&lt;/p&gt;
&lt;h4 id=&quot;写在前面：&quot;&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;本文适合有一定dp基础的读者阅读，用来复习回顾背包相关问题，遇到类似问题可快速秒掉。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://rookieyin.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="01背包" scheme="http://rookieyin.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>谈谈一致性哈希算法</title>
    <link href="http://rookieyin.github.io/8a4e41d05d43/"/>
    <id>http://rookieyin.github.io/8a4e41d05d43/</id>
    <published>2022-04-08T12:38:14.000Z</published>
    <updated>2022-06-01T14:28:00.157Z</updated>
    
    
    <summary type="html">&lt;p&gt;这篇文章主要搬运自&lt;a href=&quot;https://segmentfault.com/a/1190000021199728&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前学习Redis集群的数据分区方案时，了解到“一致性hash算法”，今天来详细探究一下一致性hash背后的事儿！&lt;/p&gt;
&lt;p&gt;一致性hash算法主要用于解决分布式环境下的数据分区和负载均衡问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分布式环境下，如何确定那个key存储在那个节点上呢？&lt;/li&gt;
&lt;li&gt;如何保证数据或者请求分布均衡呢？也就是我们常说的负载均衡？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;利用一致性hash就能很好的解决上面两个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://rookieyin.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="分布式" scheme="http://rookieyin.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>三色标记</title>
    <link href="http://rookieyin.github.io/2bc0970c0089/"/>
    <id>http://rookieyin.github.io/2bc0970c0089/</id>
    <published>2022-03-17T14:34:49.000Z</published>
    <updated>2022-06-11T13:24:55.026Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文转自：&lt;a href=&quot;https://www.modb.pro/db/128997&quot;&gt;你对JVM三色标记的理解嘛？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三色标记法是一种垃圾回收法，它可以让JVM不发生或仅短时间发生STW(Stop The World)，从而达到清除JVM内存垃圾的目的。JVM中的&lt;strong&gt;CMS、G1垃圾回收器&lt;/strong&gt;所使用垃圾回收算法即为三色标记法。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="JVM" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/JVM/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="http://rookieyin.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
