<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RookieYin&#39;s Note</title>
  
  
  <link href="http://rookieyin.github.io/atom.xml" rel="self"/>
  
  <link href="http://rookieyin.github.io/"/>
  <updated>2022-10-04T08:20:09.064Z</updated>
  <id>http://rookieyin.github.io/</id>
  
  <author>
    <name>Yin Peng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adversarial Graph Contrastive Learning with Information Regularization</title>
    <link href="http://rookieyin.github.io/59408777a096/"/>
    <id>http://rookieyin.github.io/59408777a096/</id>
    <published>2022-10-04T11:26:03.000Z</published>
    <updated>2022-10-04T08:20:09.064Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://dl.acm.org/doi/pdf/10.1145/3485447.3512183&quot;&gt;https://dl.acm.org/doi/pdf/10.1145/3485447.3512183&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Adversarial Graph Contrastive Learning with Information Regularization，2022，WWW&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 个人觉得这篇文章创新性是比较强的，第一次看到这种将对抗训练引入对比学习中的文章，对抗训练和对比学习结合的方式也比较新颖。关于信息正则化项的理论分析，思路也很清晰，容易看懂，值得借鉴。&lt;/p&gt;
&lt;p&gt;实验部分内容不多，但是相对比较完整，ARIEL性能也还不错。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Simple unsupervised graph representation learning</title>
    <link href="http://rookieyin.github.io/e803960de55b/"/>
    <id>http://rookieyin.github.io/e803960de55b/</id>
    <published>2022-10-04T11:26:03.000Z</published>
    <updated>2022-10-04T08:48:55.948Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ojs.aaai.org/index.php/AAAI/article/view/20748/20507&quot;&gt;https://ojs.aaai.org/index.php/AAAI/article/view/20748/20507&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/YujieMo/SUGRL&quot;&gt;https://github.com/YujieMo/SUGRL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Simple unsupervised graph representation learning，2022，AAAI&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 现有的GCL方法通常时间复杂度比较高，导致难以应用到大规模数据集，主要有一下3点原因：（1）数据增强；（2）高维嵌入；（3）损失函数。本文作者提出了一种简单高效的图对比学习方法SUGRL，作者删掉了GCL中的数据增强和损失函数，并且重新设计了一个boundary loss。和现有GCL方法相比，SUGRL训练速度确实非常快，并且在节点分类任务上也具有不错的性能。总的来说，这篇文章还是不错的，值得借鉴，如果有更多关于SUGRL的理论分析和证明就更好了。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>CCGL: Contrastive Cascade Graph Learning</title>
    <link href="http://rookieyin.github.io/fbae03233e49/"/>
    <id>http://rookieyin.github.io/fbae03233e49/</id>
    <published>2022-10-03T11:26:03.000Z</published>
    <updated>2022-10-04T08:47:33.942Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2107.12576&quot;&gt;https://arxiv.org/pdf/2107.12576&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Xovee/ccgl&quot;&gt;https://github.com/Xovee/ccgl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CCGL: Contrastive Cascade Graph Learning，2022，TKDE&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;算是一篇领域迁移的文章吧，提出了CCGL模型，将对比学习引入级联图学习中，同时结合了预训练-微调模式和知识蒸馏。文章值得参考的一点应该是在级联图中如何进行数据增强，CCGL其他的模块感觉参考意义不大，有点A+B的感觉。必须要吐槽的一点是，文章Introduction和动机写的太烂了！！读这部分的时候，明显感觉到，先东拼西凑设计好模型，再编故事。虽然我们可能经常这样，但是作者故事编的有点太烂了，强行根据CCGL的功能来编这篇工作希望解决的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Augmentation-Free Self-Supervised Learning on Graphs</title>
    <link href="http://rookieyin.github.io/8ab5ae2852a0/"/>
    <id>http://rookieyin.github.io/8ab5ae2852a0/</id>
    <published>2022-10-03T11:26:03.000Z</published>
    <updated>2022-10-04T08:43:32.705Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ojs.aaai.org/index.php/AAAI/article/view/20700/20459&quot;&gt;https://ojs.aaai.org/index.php/AAAI/article/view/20700/20459&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Namkyeong/AFGRL&quot;&gt;https://github.com/Namkyeong/AFGRL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Augmentation-Free Self-Supervised Learning on Graphs ，2022，AAAI&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;挺好的一篇文章，故事讲得很完整，方法也挺新颖的。作者提出了一种无须增强的GCL方法，利用基于节点表示的kNN获取正样本集合的。在此基础上，考虑到节点的局部机构信息和全局语义信息，使用基于结构的kNN算法和聚类算法，对第一步获取到的正样本集合进行过滤，达到降噪的目的。总的来说，方法比较新，思路很清晰，故事也很完整。至于实验结果，基础对比实验效果一般，不过消融实验、可视化和参数敏感性实验都挺好的，内容比较完整。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SAIL: Self-Augmented Graph Contrastive Learning</title>
    <link href="http://rookieyin.github.io/cb2b42e6046d/"/>
    <id>http://rookieyin.github.io/cb2b42e6046d/</id>
    <published>2022-10-02T11:26:03.000Z</published>
    <updated>2022-10-04T08:17:35.410Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2009.00934&quot;&gt;https://arxiv.org/pdf/2009.00934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SAIL: Self-Augmented Graph Contrastive Learning，2022，AAAI&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt;作者提出了一种自增强GCL方法SAIL，和普通GCL方法相比，SAIL没有使用任何增强技术，而是将节点原始输入特征和GNNs学习到的节点表示看作两个视角进行对比。再此基础上，作者认为模型还存在问题，这里正负样本对的选取是通过edge connectivity来进行的，可能无法代表整个节点表示分布的全貌，并且可能导致模型偏向于链路预测任务（在其他pretext task，比如节点分类中表现一般）。为了解决这个问题，作者提出了一种self-distilling方法，包含intra-和inter-distilling两个模块。intra-distilling可以保证学习到的节点表示和原始输入特征具有相同的分布。inter-distilliing可以让浅层GNNs模拟出深层GNNs的效果，并且不存在过平滑问题。&lt;/p&gt;
&lt;p&gt;整体来说，文章还可以，实验比较丰富，实验结果也挺可观的。不过个人感觉，SAIL中的对比策略和知识蒸馏组合在一起有点A+B的意思，结构不是那么连贯，故事不够完整。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Prototypical Graph Contrastive Learning</title>
    <link href="http://rookieyin.github.io/33e72210426f/"/>
    <id>http://rookieyin.github.io/33e72210426f/</id>
    <published>2022-10-01T11:26:03.000Z</published>
    <updated>2022-10-02T05:11:20.112Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2106.09645&quot;&gt;https://arxiv.org/pdf/2106.09645&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ha-lins/pgcl&quot;&gt;https://github.com/ha-lins/pgcl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Prototypical Graph Contrastive Learning，2022，TNNLS&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-size:18px;font-weight:bold;&quot;&gt;总结：&lt;/span&gt; 文章要解决的一个核心问题就是：GCL负样本采样阶段存在的“sampling bias”问题，即可能选取到的“false negative sample”（即和目标query具有相同语义的负样本）。现有的GCL方法，对于负样本的选取基本都是均匀采样，不考虑负样本和锚点之间的相似度。作者在PGCL中首先对样本进行聚类，计算每个类别的原型向量，然后将和锚点处于不同簇的其他样本视作正负样本，处于相同簇的样本视为假负样本。另外，作者根据样本所在簇的原型和锚点所在簇原型之间距离计算权重用于对比损失的定义。感觉目前学术界对于GCL的研究，基本都是将CV和NLP中对比学习方法拓展到图邻域，可以多多关注CV中对比学习的最新进展。2021ICLR中有一篇名为“ PROTOTYPICAL CONTRASTIVE LEARNING OF UNSUPERVISED REPRESENTATIONS”的CV论文，我没有看着篇文章，不知道和本文是否有联系。2021ICLR还有一篇“ CONTRASTIVE LEARNING WITH HARD NEGATIVE SAMPLES ”的论文，和本文负样本采样思想差不多。因此，总的来看作者可能还是将CV中的方法迁移到图学习中。&lt;/p&gt;</summary>
    
    
    
    <category term="论文笔记" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E5%9B%BE%E5%AD%A6%E4%B9%A0/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="图学习" scheme="http://rookieyin.github.io/tags/%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="对比学习" scheme="http://rookieyin.github.io/tags/%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树</title>
    <link href="http://rookieyin.github.io/40756c5f7820/"/>
    <id>http://rookieyin.github.io/40756c5f7820/</id>
    <published>2022-09-12T05:39:48.000Z</published>
    <updated>2022-10-04T14:07:46.292Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;一些定义&quot;&gt;一些定义&lt;/h2&gt;
&lt;p&gt;给定N个带有权值的叶子节点，构造一棵二叉树，如果该树的&lt;strong&gt;带权路径长度最小&lt;/strong&gt;，那么它是一棵最优二叉树，即&lt;strong&gt;哈夫曼树&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://rookieyin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://rookieyin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈夫曼树" scheme="http://rookieyin.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>行为型——责任链模式</title>
    <link href="http://rookieyin.github.io/1b76d52cc09c/"/>
    <id>http://rookieyin.github.io/1b76d52cc09c/</id>
    <published>2022-08-23T07:08:10.000Z</published>
    <updated>2022-10-04T14:03:20.996Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;</summary>
        
      
    
    
    
    <category term="设计模式" scheme="http://rookieyin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://rookieyin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优</title>
    <link href="http://rookieyin.github.io/77a9c8309105/"/>
    <id>http://rookieyin.github.io/77a9c8309105/</id>
    <published>2022-08-17T14:34:49.000Z</published>
    <updated>2022-10-04T13:48:16.107Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;何时进行jvm调优&quot;&gt;何时进行JVM调优&lt;/h2&gt;
&lt;p&gt;遇到以下情况，就需要考虑进行JVM调优了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heap内存（老年代）持续上涨达到设置的最大内存值；&lt;/li&gt;
&lt;li&gt;Full GC 次数频繁；&lt;/li&gt;
&lt;li&gt;GC 停顿时间过长（超过1秒）；&lt;/li&gt;
&lt;li&gt;应用出现OutOfMemory 等内存异常；&lt;/li&gt;
&lt;li&gt;应用中有使用本地缓存且占用大量内存空间；&lt;/li&gt;
&lt;li&gt;系统吞吐量与响应性能不高或下降。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="JVM" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/JVM/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="优化" scheme="http://rookieyin.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>联合索引怎么用</title>
    <link href="http://rookieyin.github.io/426b292b8fce/"/>
    <id>http://rookieyin.github.io/426b292b8fce/</id>
    <published>2022-08-11T06:28:18.000Z</published>
    <updated>2022-10-04T13:50:35.877Z</updated>
    
    
    <summary type="html">&lt;p&gt;InnoDB中，除了聚簇索引和单个列的辅助索引外，我们还可以将多个列建立联合索引：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ADD&lt;/span&gt; INDEX abc(a, b, c)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过上面一行SQL，我们就可以建立a、b、c之间的联合索引。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="MySQL" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/MySQL/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="http://rookieyin.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://rookieyin.github.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://rookieyin.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Java静态绑定与动态绑定</title>
    <link href="http://rookieyin.github.io/6a5e2bd46dc2/"/>
    <id>http://rookieyin.github.io/6a5e2bd46dc2/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:31:05.018Z</updated>
    
    
    <summary type="html">&lt;p&gt;文章转自&lt;a href=&quot;https://www.jianshu.com/p/4277bbcab647&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、当子类和父类存在同一个方法，子类重写了父类的方法，程序在运行时调用方法是调用父类的方法还是子类的重写方法呢？&lt;br&gt;
2、当一个类中存在方法名相同但参数不同(重载)的方法，程序在执行的时候该如何辨别区分使用哪个方法呢？&lt;br&gt;
在Java中我们使用静态绑定（static binding）和动态绑定（Dynamic binding）来解决，那么什么是绑定？什么是静态绑定？什么又是动态绑定？有什么区别？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java， 多态" scheme="http://rookieyin.github.io/tags/Java%EF%BC%8C-%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>static代码块、构造函数等执行顺序</title>
    <link href="http://rookieyin.github.io/4ad132728a73/"/>
    <id>http://rookieyin.github.io/4ad132728a73/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:31:24.922Z</updated>
    
    
    <summary type="html">&lt;p&gt;文章转自&lt;a href=&quot;https://www.jianshu.com/p/0c4223e0702b&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序：&lt;br&gt;
父类静态块–&amp;gt;子类静态块–&amp;gt; main方法–&amp;gt;父类构造代码块 --&amp;gt;父类构造函数–&amp;gt;子类构造代码块–&amp;gt;子类构造函数，同一级别代码块按顺序执行。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类和继承</title>
    <link href="http://rookieyin.github.io/e2218c103027/"/>
    <id>http://rookieyin.github.io/e2218c103027/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:17:20.905Z</updated>
    
    
    <summary type="html">&lt;p&gt;文章转自：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3803432.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java三大特性</title>
    <link href="http://rookieyin.github.io/01a29da4a7e8/"/>
    <id>http://rookieyin.github.io/01a29da4a7e8/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:17:58.961Z</updated>
    
    
    <summary type="html">&lt;p&gt;Java作为面向对象语言，具有封装、继承、多态三大特性，以及重写和重载功能。本文对这几个概念做一个详细介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java新特性</title>
    <link href="http://rookieyin.github.io/df61fc7edb7a/"/>
    <id>http://rookieyin.github.io/df61fc7edb7a/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:36:11.941Z</updated>
    
    
    <summary type="html">&lt;p&gt;Java每年发布两个正式版本，每3年发布一个TLS， 意味着Java 8 ，Java 11， Java 17 才可能被大规模使用。&lt;/p&gt;
&lt;p&gt;本文简单总结一下Java8、Java11和Java17的新特性。文章内容主要总结自&lt;a href=&quot;https://pdai.tech/md/java/java8up/java-8-up-overview.html&quot;&gt;Java全栈知识体系&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>try-catch-finally</title>
    <link href="http://rookieyin.github.io/520ad09caee4/"/>
    <id>http://rookieyin.github.io/520ad09caee4/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:30:41.073Z</updated>
    
    
    <summary type="html">&lt;p&gt;面试的时候遇到try-catch-finally的执行顺序相关问题，发现忘了这个知识点。以此文记录下该知识点。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="异常" scheme="http://rookieyin.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java异常机制</title>
    <link href="http://rookieyin.github.io/bcc8998c2008/"/>
    <id>http://rookieyin.github.io/bcc8998c2008/</id>
    <published>2022-08-05T14:34:49.000Z</published>
    <updated>2022-10-04T13:34:06.832Z</updated>
    
    
    <summary type="html">&lt;p&gt;文章转自&lt;a href=&quot;https://pdai.tech/md/java/basic/java-basic-x-exception.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。本文综合多篇文章后，总结了Java 异常的相关知识，希望可以提升你对Java中异常的认知效率。&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java基础知识" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="异常" scheme="http://rookieyin.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized和Lock对比</title>
    <link href="http://rookieyin.github.io/f41ccc86ccbc/"/>
    <id>http://rookieyin.github.io/f41ccc86ccbc/</id>
    <published>2022-08-04T14:34:49.000Z</published>
    <updated>2022-10-04T13:20:55.510Z</updated>
    
    
    <summary type="html">&lt;p&gt;synchronized和lock是Java中提供的两种常用的锁机制，两者对比如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使用方法上&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;synchronize，是Java提供的一个关键字，可以加在方法上，也可以加在特定代码块中&lt;/li&gt;
&lt;li&gt;lock，是Java提供的一个借口，常用的有ReentrantLock，通过调用lock()和unlock()获取锁和释放锁。通常在finally中添加unlock()防止死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能上&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;synchronized，JDK1.5中，synchronized是非常重量级的操作，但是从1.6开始，进行了优化，引入了锁升级机制，性能得到了较大提升。&lt;/li&gt;
&lt;li&gt;lock，是乐观锁，通过CAS实现，在资源竞争激烈的情况下，使用lock性能会更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持的功能上&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;synchronized，支持的功能简单，是公平锁，不支持中断&lt;/li&gt;
&lt;li&gt;lock，支持更多的功能，包括公平、非公平锁，trylock、读写锁、condition等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="http://rookieyin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="http://rookieyin.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>wait、notify、park、sleep、yield等对比</title>
    <link href="http://rookieyin.github.io/47f68d9d8215/"/>
    <id>http://rookieyin.github.io/47f68d9d8215/</id>
    <published>2022-08-04T14:34:49.000Z</published>
    <updated>2022-10-04T13:38:00.743Z</updated>
    
    
    <summary type="html">&lt;center&gt;&lt;img src=&quot;/images/20210301201459977.png&quot; style=&quot;width:800px;&quot;&gt;&lt;/img&gt;&lt;/center&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="http://rookieyin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="http://rookieyin.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Future</title>
    <link href="http://rookieyin.github.io/008aa26390aa/"/>
    <id>http://rookieyin.github.io/008aa26390aa/</id>
    <published>2022-08-04T14:34:49.000Z</published>
    <updated>2022-10-04T13:42:02.833Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;future相关概念&quot;&gt;Future相关概念&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;官放时这样描述Future接口的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&amp;lt;?&amp;gt; and return null as a result of the underlying task.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="后端" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    <category term="Java并发" scheme="http://rookieyin.github.io/categories/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="后端" scheme="http://rookieyin.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Java" scheme="http://rookieyin.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="http://rookieyin.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
