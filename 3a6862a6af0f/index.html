<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta name="baidu-site-verification" content="code-rk2CNV4xgj" />
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>RabbitMQ概述 |  RookieYin&#39;s Note</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/2.jpg" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    <link rel="alternate" href="/atom.xml" title="RookieYin's Note" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
  </html>
</html>


<body>
<div id="app">
    
    
    <div class="sidebar">
        <!--<button class="navbar-toggle"></button>-->
<nav class="navbar">
  <div class="logo">
    <a href="/">
      <img src="/images/2.jpg"
           style="border-radius: 50%;max-width: none;">
    </a>
  </div>
  <div class = nav-title style="font-size: 2.5rem;color: #ffffff;margin-left: 4rem;font-weight: bold;min-width: 23rem">
    RookieYin's Note
  </div>
  <div class="nav nav-main">
    
    <div class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </div>
    
    <div class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </div>
    
    <div class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </div>
    
    <div class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </div>
    
    <div class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </div>
    
    <div class="nav-item">
      <a class="nav-item-link" href="/about-me/2021">关于我</a>
    </div>
    
      <div class="nav-item">
        <div class="nav-item-link navbar-menu-wrap">
          <div class="navbar-menu"></div>
        </div>
      </div>
    <div class = "nav-item">
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
    </div>
  </div>
</nav>
<nav class="navbar2">
  <div style="position: relative;">
      <div style="height: 4.8rem;display: inline-block;margin-top:1rem;margin-left:1rem;">
        <a href="/">
          <img src="/images/2.jpg"
               style="border-radius: 50%;max-width: none;width:4.8rem">
        </a>
      </div>
    <div class="navbar-title2" style="font-size: 2.5rem;color: #ffffff;margin-left: 4rem;font-weight: bold;margin-top:1rem;
    min-width: 23rem;height: 4.8rem;overflow: hidden;">
      <span style="line-height: 4.8rem;">RookieYin's Note</span>
    </div>
    <div style="display: inline-block;position: absolute;top:50%;height:50%;transform:translate(-50%,-50%);right:4rem;margin-top: 1rem;">
      <div class="navbar-menu-wrap">
        <div class="navbar-menu"></div>
      </div>
    </div>
    <div style="display: inline-block;position: absolute;top:50%;height:50%;transform:translate(-50%,-50%);right:0;">
      <a class="nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
    </div>
  </div>
  <div style="display: inline-block;text-align: center;width: 100%;padding-bottom: 1rem;">
    
    <div class="nav-item2">
      <a class="nav-item-link2" href="/">主页</a>
    </div>
    
    <div class="nav-item2">
      <a class="nav-item-link2" href="/archives">归档</a>
    </div>
    
    <div class="nav-item2">
      <a class="nav-item-link2" href="/categories">分类</a>
    </div>
    
    <div class="nav-item2">
      <a class="nav-item-link2" href="/tags">标签</a>
    </div>
    
    <div class="nav-item2">
      <a class="nav-item-link2" href="/friends">友链</a>
    </div>
    
    <div class="nav-item2">
      <a class="nav-item-link2" href="/about-me/2021">关于我</a>
    </div>
    
  </div>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>

    </div>
    <main class="content">
        <section class="outer">
  <article
  id="post-2 后端/消息队列/RabbitMQ概述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  RabbitMQ概述
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/3a6862a6af0f/" class="article-date">
  <time datetime="2022-06-14T05:45:23.000Z" itemprop="datePublished">2022-06-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a> / <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
  </div>

  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">15 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="消息队列基础">消息队列基础</h2>
<h3 id="什么是消息队列">什么是消息队列</h3>
<p><strong>消息</strong>指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。</p>
<p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE5LzE3MzY3NTNjNDc1M2M2Zjk.png" style="width:400px;"></img></center> 
<a id="more"></a>
<h3 id="为什么使用消息队列">为什么使用消息队列</h3>
<p>主要有三个作用：</p>
<ul>
<li>
<p><strong>解耦</strong>： 如图所示。假设有系统B、C、D都需要系统A的数据，于是系统A调用三个方法发送数据到B、C、D。这时，系统D不需要了，那就需要在系统A把相关的代码删掉。假设这时有个新的系统E需要数据，这时系统A又要增加调用系统E的代码。为了降低这种强耦合，就可以使用MQ，<strong>系统A只需要把数据发送到MQ，其他系统如果需要数据，则从MQ中获取即可</strong>。</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE5LzE3MzY3OGM3YTgxY2MxYzA.png" style="width:600px;"></img></center> 
</li>
<li>
<p><strong>异步</strong>： 如图所示。一个客户端请求发送进来，系统A会调用系统B、C、D三个系统，同步请求的话，响应时间就是系统A、B、C、D的总和，也就是800ms。<strong>如果使用MQ，系统A发送数据到MQ，然后就可以返回响应给客户端，不需要再等待系统B、C、D的响应，可以大大地提高性能</strong>。对于一些非必要的业务，比如发送短信，发送邮件等等，就可以采用MQ。</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE5LzE3MzY3OTQ1YThjNGRmNzM.png" style="width:600px;"></img></center> 
</li>
<li>
<p><strong>削峰</strong>：如图所示。这其实是MQ一个很重要的应用。假设系统A在某一段时间请求数暴增，有5000个请求发送过来，系统A这时就会发送5000条SQL进入MySQL进行执行，MySQL对于如此庞大的请求当然处理不过来，MySQL就会崩溃，导致系统瘫痪。<strong>如果使用MQ，系统A不再是直接发送SQL到数据库，而是把数据发送到MQ，MQ短时间积压数据是可以接受的，然后由消费者每次拉取2000条进行处理，防止在请求峰值时期大量的请求直接发送到MySQL导致系统崩溃</strong>。</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE5LzE3MzY3YTlkOTAyY2NhNGY.png" style="width:600px;"></img></center> 
</li>
</ul>
<h3 id="常见消息队列产品">常见消息队列产品</h3>
<h4 id="mq产品">MQ产品</h4>
<ol>
<li>
<p><strong>ZeroMQ</strong>：号称最快的消息队列系统，尤其针对大吞吐量的需求场景。扩展性好，开发比较灵活，采用C语言实现，实际上只是一个socket库的重新封装，如果做为消息队列使用，需要开发大量的代码。ZeroMQ仅提供非持久性的队列，也就是说如果down机，数据将会丢失。其中，Twitter的Storm中使用ZeroMQ作为数据流的传输。</p>
</li>
<li>
<p><strong>RabbitMQ</strong>：结合erlang语言本身的并发优势，支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。性能较好，但是不利于做二次开发和维护。</p>
</li>
<li>
<p><strong>ActiveMQ</strong>: 历史悠久的开源项目，是Apache下的一个子项目。已经在很多产品中得到应用，实现了JMS1.1规范，可以和spring-jms轻松融合，实现了多种协议，不够轻巧（源代码比RocketMQ多），支持持久化到数据库，对队列数较多的情况支持不好，不过我们的项目中并不会建很多的队列。</p>
</li>
<li>
<p><strong>Redis</strong>：做为一个基于内存的K-V数据库，其提供了消息订阅的服务，可以当作MQ来使用，目前应用案例较少，且不方便扩展。对于RabbitMQ和Redis的入队和出队操作，各执行100万次，每10万次记录一次执行时间。测试数据分为 128Bytes、512Bytes、1K和10K四个不同大小的数据。实验表明：入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如 果数据大小超过了10K，Redis则慢的无法忍受；出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于 Redis。</p>
</li>
<li>
<p><strong>RocketMQ</strong>:  阿里巴巴的MQ中间件，在其多个产品下使用，并能够撑住双十一的大流量，他并没有实现JMS规范，使用起来很简单。部署由一个 命名服务（nameserver）和一个代理（broker）组成，nameserver和broker以及producer都支持集群，队列的容量受机器硬盘的限制，队列满后可以支持持久化到硬盘（也可以自己适配代码，将其持久化到NOSQL数据库中），队列满后会影响吞吐量，可以采用主备来保证稳定性，支持回溯消费，可以在broker端进行消息过滤。</p>
</li>
<li>
<p><strong>Jafka/Kafka</strong>：Kafka是Apache下的一个子项目，是一个高性能跨语言分布式Publish/Subscribe消息队列系统，而Jafka是在Kafka 之上孵化而来的，即Kafka的一个升级版。</p>
<p>具有以下特性：快速持久化，可以在O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以 达到10W/s的吞吐速率；完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现复杂均衡；支持 Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过 Hadoop的并行加载机制来统一了在线和离线的消息处理，这一点也是本课题所研究系统所看重的。</p>
<p>Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</p>
</li>
</ol>
<h4 id="mq选型">MQ选型</h4>
<p>针对消息中间件的选择可以从以下方面进行考虑，以ActiveMQ和RocketMQ对比作为案例。</p>
<ol>
<li>
<p><strong>优先级</strong>：RocketMQ需要新建一个特殊队列来接收优先级高的队列，无法实现从0-65535这种细粒度的控制，ActiveMQ可以精细控制。</p>
</li>
<li>
<p><strong>顺序</strong>：activeMQ无法保证严格的顺序，RocketMQ可以保证严格的消费顺序。</p>
</li>
<li>
<p><strong>持久化</strong>：都支持</p>
</li>
<li>
<p><strong>稳定性</strong>：RoketMQ在稳定性上可能更值得信赖，支持多种集群方案。</p>
</li>
<li>
<p><strong>消息过滤</strong>：ActiveMQ仅支持在客户端消费的时候进行判断是否是自己需要的消息，RocketMQ可以在broker端进行过滤，对于我们的消息总线，这里可以节省大量的网络传输是否会有消息重发造成的重复消费：RocketMQ可以保证，ActiveMQ无法保证。</p>
</li>
<li>
<p><strong>回溯消费</strong>：即重新将某一个时刻之前的消息重新消费一遍，RocketMQ支持，ActiveMQ不支持（RocketMQ的队列是持久化到硬盘的，定期进行清除。</p>
</li>
<li>
<p><strong>事务</strong>：都支持</p>
</li>
<li>
<p><strong>定时消费</strong>：RocketMQ支持</p>
</li>
<li>
<p><strong>消息堆积</strong>：就是当缓存消息的内存满了之后的解决方案，一种是丢弃策略，这种不会影响吞吐量，还有一种就是将消息持久化到磁盘，这种会影响吞吐量，在评估影响程度上，RocketMQ的成绩稍微好一点。</p>
</li>
<li>
<p><strong>客户端不在线</strong>：RocketMQ可以在客户端上线后继续将未消费的消息推送到客户端。</p>
</li>
</ol>
<h2 id="rabbitmq基本概念">RabbitMQ基本概念</h2>
<p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。首先要知道一些RabbitMQ的特点，<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/?spm=a2c6h.12873639.article-detail.5.433733dfnziQJk">官网</a>可查：</p>
<ul>
<li><strong>可靠性</strong>。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li>
<li><strong>灵活的分发消息策略</strong>。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li>
<li><strong>支持集群</strong>。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li>
<li><strong>多种协议</strong>。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li><strong>支持多种语言客户端</strong>。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li>
<li><strong>可视化管理界面</strong>。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li>
<li><strong>插件机制</strong>。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li>
</ul>
<h3 id="rabbitmq组成部分">RabbitMQ组成部分</h3>
<p>RabbitMQ大致由一下几部分组成：</p>
<ul>
<li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。</li>
<li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li>
<li>Queue：消息队列，存储消息的队列。</li>
<li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li>
<li>Consumer：消息消费者。消费队列中存储的消息。</li>
</ul>
<p>这些组成部分是如何协同工作的呢，大概的流程如下，请看下图：</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzIyLzE3Mzc3MjhiNzI4NTJkNzc.png" style="width:600px;"></img></center> 
<ul>
<li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li>
<li>生产者声明交换机类型、名称、是否持久化等。</li>
<li>生产者发送消息，并指定消息是否持久化等属性和routing key。</li>
<li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li>
<li>消费者监听接收到消息之后开始业务处理。</li>
</ul>
<h3 id="exhange类型及用法">Exhange类型及用法</h3>
<h4 id="direct-exchange">Direct Exchange</h4>
<p>直连交换机意思是此交换机需要绑定一个队列，要求<strong>该消息与一个特定的路由键完全匹配</strong>。简单点说就是一对一的，点对点的发送。</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzIyLzE3Mzc3M2ZlNDU1Njk4ODU.png" style="width:400px;"></img></center> 
<h4 id="fanout-exchange">Fanout Exchange</h4>
<p>这种类型的交换机需要将队列绑定到交换机上。<strong>一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</strong>。很像子网广播，每台子网内的主机都获得了一份复制的消息。简单点说就是发布订阅。</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzIzLzE3Mzc3NDIwM2VlNWFmZDM.png" style="width:400px;"></img></center> 
<h4 id="topic-exchange">Topic Exchange</h4>
<p>直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：&quot;*&quot; 、 “#”。需要注意的是通配符前面必须要加上&quot;.&quot;符号。</p>
<p><code>*</code> 符号：有且只匹配一个词。比如 <code>a.*</code>可以匹配到&quot;a.b&quot;、“a.c”，但是匹配不了&quot;a.b.c&quot;。</p>
<p><code>#</code> 符号：匹配一个或多个词。比如&quot;rabbit.#“既可以匹配到&quot;rabbit.a.b”、“rabbit.a”，也可以匹配到&quot;rabbit.a.b.c&quot;。</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI0LzE3MzdjYzJlMzVhYmIwYzI.png" style="width:600px;"></img></center> 
<h4 id="headers-exchange">Headers Exchange</h4>
<p>这种交换机用的相对没这么多。<strong>它跟上面三种有点区别，它的路由不是用routingKey进行路由匹配，而是在匹配请求头中所带的键值进行路由</strong>。如图所示：</p>
<center><img src="/images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI1LzE3Mzg0OTk2NzFlMTk1NWU.png" style="width:600px;"></img></center> 
<center><img src="./images/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzI1LzE3Mzg0OWEwMTRkNTc2ZTU.png" style="width:600px;"></img></center> 
<p>创建队列需要设置绑定的头部信息，有两种模式：<strong>全部匹配和部分匹配</strong>。如上图所示，交换机会根据生产者发送过来的头部信息携带的键值去匹配队列绑定的键值，路由到对应的队列。</p>
<h3 id="6种消息模型">6种消息模型</h3>
<h4 id="基本消息类型">基本消息类型</h4>
<center><img src="/images/20190610232537261.png" style="width:400px;"></img></center> 
<p>在上图的模型中，有以下概念：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：消息队列，图中红色部分。可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li>
</ul>
<h4 id="work消息模型">work消息模型</h4>
<p>工作队列或者竞争消费者模式</p>
<center><img src="/images/20190611201227139.png" style="width:400px;"></img></center> 
<p>work queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息，但是一个消息只能被一个消费者获取。</p>
<p>这个消息模型在Web应用程序中特别有用，可以处理短的HTTP请求窗口中无法处理复杂的任务。</p>
<p>接下来我们来模拟这个流程：</p>
<p>P：生产者：任务的发布者</p>
<p>C1：消费者1：领取任务并且完成任务，假设完成速度较慢（模拟耗时）</p>
<p>C2：消费者2：领取任务并且完成任务，假设完成速度较快</p>
<h4 id="发布订阅模型">发布订阅模型</h4>
<p>Publish/subscribe模型示意图 ：</p>
<center><img src="/images/20190611200955466.png" style="width:400px;"></img></center> 
<p>对于生产者，和前面两种模式不同：</p>
<ul>
<li>1） 声明Exchange，不再声明Queue</li>
<li>2） 发送消息到Exchange，不再发送到Queue</li>
</ul>
<p><strong>1、publish/subscribe与work queues有什么区别？</strong></p>
<ul>
<li>
<p>区别：</p>
<p>1）work queues不用定义交换机，而publish/subscribe需要定义交换机。</p>
<p>2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。</p>
<p>3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实际上work queues会将队列绑定到默认的交换机 。</p>
</li>
<li>
<p>相同点：</p>
<p>所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。</p>
</li>
</ul>
<p><strong>2、实际工作用 publish/subscribe还是work queues？</strong></p>
<p>建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大（也可以做到同一队列竞争），并且发布订阅模式可以指定自己专用的交换机。</p>
<h4 id="routing路由模型">Routing路由模型</h4>
<p>Routing模型示意图：</p>
<center><img src="/images/20190611151532501.png" style="width:500px;"></img></center> 
<p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>
<p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>
<p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p>
<p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>
<h4 id="topics通配符模型">Topics通配符模型</h4>
<p>Topics模型示意图：</p>
<center><img src="/images/20190611154905286.png" style="width:500px;"></img></center> 
<p>每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。</p>
<p>Routingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms</p>
<p>通配符规则：</p>
<p>#：匹配一个或多个词</p>
<p>*：匹配不多不少恰好1个词</p>
<p>举例：</p>
<p>audit.#：能够匹配audit.irs.corporate 或者 audit.irs</p>
<p>audit.*：只能匹配audit.irs</p>
<p>从示意图可知，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的Routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</p>
<p>我们创建了三个绑定：Q1绑定了“<em>.orange.</em>”，Q2绑定了“.<em>.</em>.rabbit”和“lazy.＃”。</p>
<p>Q1匹配所有的橙色动物。</p>
<p>Q2匹配关于兔子以及懒惰动物的消息。</p>
<h4 id="rpc模型">RPC模型</h4>
<p>RPC模型示意图：</p>
<center><img src="/images/20190611200118579.png" style="width:500px;"></img></center> 
<p><strong>一、基本概念</strong></p>
<p>Callback queue 回调队列，客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址reply_to。</p>
<p>Correlation id 关联标识，客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有correlation_id属性，这样客户端在回调队列中根据correlation_id字段的值就可以分辨此响应属于哪个请求。</p>
<p><strong>二、流程说明</strong></p>
<ul>
<li>当客户端启动的时候，它创建一个匿名独享的回调队列。</li>
<li>在 RPC 请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。</li>
<li>将请求发送到一个 rpc_queue 队列中。</li>
<li>服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。</li>
<li>客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用。</li>
</ul>
<h2 id="常见面试题">常见面试题</h2>
<ol>
<li>
<p><strong>避免消息堆积？</strong></p>
<p>1） 采用workqueue，多个消费者监听同一队列。</p>
<p>2）接收到消息以后，而是通过线程池，异步消费。</p>
</li>
<li>
<p><strong>如何避免消息丢失？</strong></p>
<p>1） 消费者的ACK机制。可以防止消费者丢失消息。但是，如果在消费者消费之前，MQ就宕机了，消息就没了？</p>
<p>2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化</p>
</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/769883">https://developer.aliyun.com/article/769883</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15076204/2582716">https://blog.51cto.com/u_15076204/2582716</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jisuanjiguoba/article/details/118722644">https://blog.csdn.net/jisuanjiguoba/article/details/118722644</a></li>
</ol>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<!--<div class="wx-share-modal">-->
<!--    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>-->
<!--    <p>扫一扫，分享到微信</p>-->
<!--    <div class="wx-qrcode">-->
<!--      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://rookieyin.github.io/3a6862a6af0f/" alt="微信分享二维码">-->
<!--    </div>-->
<!--</div>-->

<div id="share-mask"></div>
  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/47d678eb0d18/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            差分算法总结
          
        </div>
      </a>
    
    
      <a href="/b991887dca39/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">快排的3种实现方式</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "f9XmUV7HVprPCNptggBNBhWR-gzGzoHsz",
    app_key: "H73Viqo3lADopEFgshq3XrXs",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
        <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> Yin Peng
      </li>
    </ul>
    <ul>
      <li>引擎:
        <a style="color: #0681d0" target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a>
        &nbsp;&nbsp;|&nbsp;&nbsp;主题:修改自
        <a style="color: #0681d0" target="_blank" rel="noopener" href="https://shen-yu.gitee.io/">Ayer</a>
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>

        <div class="float_btns">
            <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

        </div>
    </main>

    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wxpay.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
</div>
</body>

</html>
